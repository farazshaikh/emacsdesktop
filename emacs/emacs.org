* !! WARNING !! EMACS Configuration is infinitely MALLEABLE.
;; YOU WILL SPEND INORDINATE AMOUNTS OF TIME TUNING IT - GO BACK USE VSCODE
* Emacs configuration file
#+BEGIN_SRC emacs-lisp
  ;;; package -- Emacs Programming IDE
  ;;         Emacs setting for day to day programming
  ;;
  ;;; Commentary:
  ;;;         LSP based emacs programming setup ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; -*- lexical-binding: t; -*-
  ;;; Code:
#+END_SRC
* Emacs Version check
#+BEGIN_SRC emacs-lisp
  (defun es/check-version()
    "Check that Emacs version is at the least supported version."
    (if (version< emacs-version  "24.4")
        (error "Script depends on Emacs version being greater than 24.4")
      (message "Version greater or equal to 24.4")))
  (es/check-version)
#+END_SRC
* Faster GC
#+BEGIN_SRC emacs-lisp
  ;; Make startup faster by reducing the frequency of garbage
  ;; collection.  The default is 800 kilobytes.  Measured in bytes.
  ;; Following setting saves 0.2 seconds an brings startup times down to 1.1sec
  ;; (setq gc-cons-threshold (* 250 1000 1000))
  (setq package-enable-at-startup nil
        message-log-max 16384
        gc-cons-threshold 402653184
        gc-cons-percentage 0.6
        auto-window-vscroll nil)

  (add-hook 'after-init-hook
            `(lambda ()
               (setq gc-cons-threshold 800000
                     gc-cons-percentage 0.1)
               (garbage-collect)) t)
#+END_SRC



* Package Mgmt
** Package Source Setup
#+BEGIN_SRC emacs-lisp
  (defvar hostname
  (or (getenv "HOSTNAME") (getenv "COMPUTERNAME") "unknown")
  "hostname of this machine")
  (defun es/setup-package-mgmt()
    "Setup the package management for EOS."
    (message "installing use package")
    (require 'package)
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
    ;; Comment/uncomment this line to enable MELPA Stable if desired.  See `package-archive-priorities`
    ;; and `package-pinned-packages`. Most users will not need or want to do this.
    (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
    (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/") t)
    (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
    (package-initialize)

    (unless package-archive-contents
      (package-refresh-contents))

    (unless (package-installed-p 'use-package)
      (package-install 'use-package))
    (message "es/setup-package-mgmt"))

  (defun package-reinstall-all()
    (interactive)
    (dolist (package-name package-activated-list)
      (package-reinstall package-name)))
  (es/setup-package-mgmt)
#+END_SRC
** Bootstrap use package
#+BEGIN_SRC emacs-lisp
    ;;;;;;;;;;;;;;;;;;;;;;;
  ;; Package Setup     ;;
    ;;;;;;;;;;;;;;;;;;;;;;;
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
  (setq use-package-compute-statistics t)
  ;;(setq use-package-always-pin "melpa")
  (use-package auto-package-update
    :disabled
    :config
    (auto-package-update-maybe))

  (use-package use-package-hydra)
  (use-package diminish
    :demand)

  ;; quelpa
  (use-package quelpa)
  (use-package quelpa-use-package
    :init (setq quelpa-update-melpa-p nil)
    :config (quelpa-use-package-activate-advice))
#+END_SRC


* Emacs Editor settings
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :init
    ;;(set-background-color "grey2")
    (setq
     inhibit-startup-screen t
     scroll-step 1
     select-enable-clipboard t
     compilation-scroll-output 'first-error
     dabbrev-case-fold-search nil

     ;; TAB cycle if there are only few candidates
     completion-cycle-threshold 3

     ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
     ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
     read-extended-command-predicate #'command-completion-default-include-p

     ;; Enable indentation+completion using the TAB key.
     ;; `completion-at-point' is often bound to M-TAB.
     tab-always-indent 'complete)

    ;; window/frame selection preference
    (setq display-buffer-base-action
          '((display-buffer-reuse-window
             display-buffer-same-window
             display-buffer-in-previous-window
             display-buffer-use-some-window)))

    (setq ring-bell-function
          (lambda nil
            (let
                ((orig-fg
                  (face-foreground 'mode-line)))
              (set-face-foreground 'mode-line "#6495ED")
              (run-with-idle-timer 0.1 nil
                                   (lambda
                                     (fg)
                                     (set-face-foreground 'mode-line fg))
                                   orig-fg))))
    (set-face-background 'vertical-border "grey2")

    (progn
     (menu-bar-mode -1)
     (tool-bar-mode -1)
     ;;(scroll-bar-mode -1)
     (global-eldoc-mode 1)
     (global-visual-line-mode t)
     ;; default 8 pixel fringes on both sides
     ;; fringe-mode nil
     (savehist-mode 1)
     (line-number-mode 1)
     (column-number-mode 1)
     (show-paren-mode 1)
     (global-hl-line-mode 1)
     (which-function-mode -1)
     (xterm-mouse-mode 1)
     (abbrev-mode 1)
     ;; kill tabs
     (indent-tabs-mode nil))

    (message "[INFO] es/emacs-base-settings"))
#+END_SRC

* Helper functions
#+BEGIN_SRC emacs-lisp
  (defun warn-if-executable-not-found(filename help)
    "Check for executable specified by FILENAME.  HELP is printed if file is not found."
    (let ((full-path (executable-find filename)))
      (if full-path
          (message "[INFO] %s: %s" filename full-path)
        (message " [WARN] %s file not found: Help %s" filename help))))

  (defun es/unsafe-signature-override()
    "DEPRECATED: Override package signature check requirements."
    (package-initialize)
    (unless (package-installed-p 'gnu-elpa-keyring-update)
      (progn
        (setq package-check-signature nil)
        (es/setup-package-mgmt)
        (package-install 'gnu-elpa-keyring-update)
        (setq package-check-signature t)))
    (message "[INFO] es/setup-package-mgmt"))
  ;;(es/unsafe-signature-override)
#+END_SRC
* Emacs workarounds
#+BEGIN_SRC emacs-lisp
  ;;;;;;;;;;;;;;;
  ;;Workarounds;;
  ;;;;;;;;;;;;;;;
  ;;https://stackoverflow.com/questions/12965814/emacs-how-can-i-eliminate-whitespace-mode-in-auto-complete-pop-ups/27960576#27960576
  (defun my:force-modes (rule-mode &rest modes)
    "RULE-MODE MODES switch on/off several modes depending of state of the controlling minor mode."
    (let ((rule-state (if rule-mode 1 -1)
                      ))
      (mapcar (lambda (k) (funcall k rule-state)) modes)
      )
    )
  (defvar my:prev-whitespace-mode nil)
  (make-variable-buffer-local 'my:prev-whitespace-mode)
  (defvar my:prev-whitespace-pushed nil)
  (make-variable-buffer-local 'my:prev-whitespace-pushed)
  (defun my:push-whitespace (&rest skip)
    "SKIP docstring :(."
    (if my:prev-whitespace-pushed () (progn
                                       (setq my:prev-whitespace-mode whitespace-mode)
                                       (setq my:prev-whitespace-pushed t)
                                       (my:force-modes nil 'whitespace-mode)
                                       ))
    )

  (defun my:pop-whitespace (&rest skip)
    "SKIP docstring :(."
    (if my:prev-whitespace-pushed (progn
                                    (setq my:prev-whitespace-pushed nil)
                                    (my:force-modes my:prev-whitespace-mode 'whitespace-mode)
                                    ))
    )
  (advice-add 'popup-draw :before #'my:push-whitespace)
  (advice-add 'popup-delete :after #'my:pop-whitespace)
  ;; End workaround auto complete and whitespace


  ;; Compilation buffer colorize
  (when (require 'ansi-color nil t)
    (defun colorize-compilation-buffer ()
      (when (eq major-mode 'compilation-mode)
        (ansi-color-apply-on-region compilation-filter-start (point-max))))
    (add-hook 'compilation-filter-hook 'colorize-compilation-buffer))

  ;;  terminal mode settings
  (add-hook 'ansi-term-mode-hook '(lambda ()
                                    (setq term-buffer-maximum-size 0)
                                    (setq-default show-trailing-whitespace nil)))
#+END_SRC



#+BEGIN_SRC emacs-lisp
   ;;;;;;;;;;;;;;;
  ;;Workarounds;;
  ;;;;;;;;;;;;;;;
  ;;https://stackoverflow.com/questions/12965814/emacs-how-can-i-eliminate-whitespace-mode-in-auto-complete-pop-ups/27960576#27960576
  (defun my:force-modes (rule-mode &rest modes)
    "RULE-MODE MODES switch on/off several modes depending of state of the controlling minor mode."
    (let ((rule-state (if rule-mode 1 -1)
                      ))
      (mapcar (lambda (k) (funcall k rule-state)) modes)
      )
    )
  (defvar my:prev-whitespace-mode nil)
  (make-variable-buffer-local 'my:prev-whitespace-mode)
  (defvar my:prev-whitespace-pushed nil)
  (make-variable-buffer-local 'my:prev-whitespace-pushed)
  (defun my:push-whitespace (&rest skip)
    "SKIP docstring :(."
    (if my:prev-whitespace-pushed () (progn
                                       (setq my:prev-whitespace-mode whitespace-mode)
                                       (setq my:prev-whitespace-pushed t)
                                       (my:force-modes nil 'whitespace-mode)
                                       ))
    )

  (defun my:pop-whitespace (&rest skip)
    "SKIP docstring :(."
    (if my:prev-whitespace-pushed (progn
                                    (setq my:prev-whitespace-pushed nil)
                                    (my:force-modes my:prev-whitespace-mode 'whitespace-mode)
                                    ))
    )
  (advice-add 'popup-draw :before #'my:push-whitespace)
  (advice-add 'popup-delete :after #'my:pop-whitespace)
  ;; End workaround auto complete and whitespace


  ;; Compilation buffer colorize
  (when (require 'ansi-color nil t)
    (defun colorize-compilation-buffer ()
      (when (eq major-mode 'compilation-mode)
        (ansi-color-apply-on-region compilation-filter-start (point-max))))
    (add-hook 'compilation-filter-hook 'colorize-compilation-buffer))

  ;;  terminal mode settings
  (add-hook 'ansi-term-mode-hook '(lambda ()
                                    (setq term-buffer-maximum-size 0)
                                    (setq-default show-trailing-whitespace nil)
                                    ))
#+END_SRC

* Emacs UX
** Writeroom
#+BEGIN_SRC emacs-lisp
  (use-package writeroom-mode
    :commands (writeroom-mode)
    :bind ("C-c z" . 'writeroom-mode)
    :config
    (setq writeroom-width 220)
    (add-hook 'writeroom-mode-hook (lambda () (display-line-numbers-mode -1)))
    :bind (:map writeroom-mode-map
                ("C-c C-w <" . #'writeroom-decrease-width)
                ("C-c C-w >" . #'writeroom-increase-width)
                ("C-c C-w =" . #'writeroom-adjust-width)
                ("s-?" . nil)
                ("C-c C-w SPC" . #'writeroom-toggle-mode-line)))
#+END_SRC

** Default text scale
#+BEGIN_SRC emacs-lisp
  (use-package default-text-scale
    :config
    (default-text-scale-mode t))
#+END_SRC

** Common font
#+BEGIN_SRC emacs-lisp
  (defun set-exec-path-from-shell-PATH ()
    "Set up Emacs' `exec-path' and PATH environment variable to match
  that used by the user's shell."
    (interactive)
    (let ((path-from-shell (replace-regexp-in-string
                            "[ \t\n]*$" "" (shell-command-to-string
                                            "$SHELL --login -c 'echo $PATH'"
                                            ))))
      (setenv "PATH" path-from-shell)
      (setq exec-path (split-string path-from-shell path-separator))))

  (defun custom/setup-font-faces ()
    (set-exec-path-from-shell-PATH)
    ;; set default font in initial window and for any new window
    (message "server after frame hook")
    (when
        (string-equal system-type "gnu/linux") ; linux
      (when (member "Fira Code" (font-family-list))
        (message "[INFO]: Font Fira Code Light")
        (add-to-list 'initial-frame-alist '(font . "Fira Code Light"))
        (add-to-list 'default-frame-alist '(font . "Fira Code Light"))))

    (when
        (string-equal hostname "bobat") ; linux
      (when (member "Source Code Pro" (font-family-list))
        (message "[INFO]: Source Code Pro-15")
        (add-to-list 'initial-frame-alist '(font . "Source Code Pro-15"))
        (add-to-list 'default-frame-alist '(font . "Source Code Pro-15")))))
  ;; run this hook after we have initialized the first time
  (add-hook 'after-init-hook 'custom/setup-font-faces)
  ;; re-run this hook if we create a new frame from daemonized Emacs
  (add-hook 'server-after-make-frame-hook 'custom/setup-font-faces)
#+END_SRC

** ADOC
#+BEGIN_SRC emacs-lisp
  (use-package adoc-mode
    :mode ("\\.adoc\\'" . adoc-mode))
#+END_SRC

** VTERM
#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :commands (vterm)
    :config
    (add-hook 'vterm-mode-hook (lambda ()
                                 (setf truncate-lines nil)
                                 (setq-local show-paren-mode nil)
                                 (setq-local show-trailing-whitespace nil)
                                 (yas-minor-mode -1)
                                 (flycheck-mode -1)
                                 (whitespace-mode -1))))
#+END_SRC

** Winner
#+BEGIN_SRC emacs-lisp
  (use-package winner
    :pin gnu
    :config
    (winner-mode 1))
#+END_SRC
* Emacs Themes
#+BEGIN_SRC emacs-lisp
  ;; The theme work in GUI mode.
  ;; For terminal mode make sure that the term support True Color
  (use-package doom-themes
    :disabled
    :config
    (load-theme 'doom-molokai t))

  (use-package monokai-pro-theme
    :disabled
    :config
    (load-theme 'monokai-pro t))

  (use-package modus-themes
    :config
    (load-theme 'modus-vivendi t))
#+END_SRC
* Emacs Mode line  (DOOM LINE)
#+BEGIN_SRC emacs-lisp
  (use-package unicode-fonts
    :if window-system)

  (use-package all-the-icons-dired
    :if window-system)
  (use-package all-the-icons
    :if window-system
    :hook
    (dired-mode . all-the-icons-dired-mode)
    :config
    (message "[INFO] es/use-package-all-the-icons")
    (when (not (member "all-the-icons" (font-family-list)))
      (all-the-icons-install-fonts t)))

  (use-package doom-modeline
    :pin melpa
    :ensure t
    :hook (after-init . doom-modeline-mode))
#+END_SRC

* Window Mgmt (Windmove Windower)
#+BEGIN_SRC emacs-lisp
  (use-package windmove
    :pin gnu
    :functions split-window-horizontally-and-follow split-window-vertically-and-follow winner-undo
    :init
    (windmove-default-keybindings 'meta)
    (defun split-window-horizontally-and-follow()
      "Focus follows the newly created window."
      (interactive)
      (split-window-horizontally)
      (other-window 1))
    (defun split-window-vertically-and-follow()
      "Focus follows the newly created window."
      (interactive)
      (split-window-vertically)
      (other-window 1))
    :bind
    ;; splits
    ("s-\\" . 'split-window-horizontally-and-follow)
    ("s-]" . 'split-window-vertically-and-follow)
    ("s-<backspace>" . 'delete-window)
    ("s-[" . 'delete-other-windows)
    ("M-u" . 'winner-undo))

  ;; dedicated buffers
  (use-package dedicated
    :commands dedicated-mode)

  (use-package windower
    :pin gnu
    :config
    (global-set-key (kbd "<s-S-left>") 'windower-swap-left)
    (global-set-key (kbd "<s-S-down>") 'windower-swap-below)
    (global-set-key (kbd "<s-S-up>") 'windower-swap-above)
    (global-set-key (kbd "<s-S-right>") 'windower-swap-right)
    (global-set-key (kbd "<s-tab>") 'windower-switch-to-last-buffer)
    (global-set-key (kbd "<s-o>") 'windower-toggle-single))
#+END_SRC

* IVY Counsel
** swiper
#+BEGIN_SRC emacs-lisp :eval no
  (use-package flx)

  (defun ivy-switch-file-search ()
    "Switch to counsel-file-jump, preserving current input."
    (interactive)
    (let ((input (ivy--input)))
      (ivy-quit-and-run (counsel-git))))

  (use-package counsel
    :bind
    (("M-x" . counsel-M-x)
     ("s-x" . counsel-M-x)
     ("C-x C-f" . counsel-find-file)
     ("C-j" . counsel-mark-ring)
     ("C-x C-j" . counsel-fzf)
     ("s-d" . counsel-linux-app)
     ("M-y" . counsel-yank-pop)
     ("C-x b" . counsel-switch-buffer)
     :map ivy-minibuffer-map
     ("M-y" . ivy-next-line)

     :map counsel-find-file-map
     ("M-." . ivy-switch-file-search)
     ("C-h" . counsel-up-directory)
     ("RET" . ivy-alt-done))
    :config
    (counsel-mode 1))

  (use-package ivy
    :disabled
    :diminish (ivy-mode)
    :bind (("<f5>" . compile)
           ("s-b" . ivy-switch-buffer))
    :custom
    (global-set-key (kbd "C-d") 'ivy-backward-delete-char)
    (ivy-use-virtual-buffers t)
    (ivy-count-format "%d/%d ")
    (ivy-display-style 'fancy)
    (ivy-wrap t)
    (ivy-use-virtual-buffers t)
    (ivy-re-builders-alist
     '((swiper . ivy--regex)
       (t      . ivy--regex-plus)))
    :config
    (ivy-mode 1))

  (use-package ivy-hydra)

  (defun ivy-fix()
    "Fix ivy prefix its a work around there is unwanted interacttion in variable settings due to use package."
    (interactive)
    (message "[INFO] fixing ivy prefixes")
    (setq ivy-initial-inputs-alist
          '((counsel-minor . "^+")
            (counsel-package . "^+")
            (counsel-org-capture . "^")
            (counsel-M-x . "")
            (counsel-describe-function . "^")
            (counsel-describe-variable . "^"))))

  (use-package ivy-posframe
    :disabled
    :config
    ;; Required for EXWM
    (if (and window-system (getenv "EOS_DESKTOP"))
        (setq ivy-posframe-parameters '((parent-frame nil))))
    ;; (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display)))
    ;; (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-center)))
    ;; (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-window-center)))
    ;; (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-bottom-left)))
    ;; (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-window-bottom-left)))
    ;; (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-point)))
    (setq ivy-posframe-display-functions-alist
          '((swiper-isearch  . ivy-posframe-display-at-window-bottom-left)
            (complete-symbol . ivy-posframe-display-at-point)
            (counsel-M-x     . ivy-posframe-display-at-point)
            (counsel-mark-ring . ivy-posframe-display-at-window-bottom-left)
            (ivy-switch-buffer . ivy-posframe-display-at-window-bottom-left)
            (t               . ivy-posframe-display-at-point)))

    (custom-set-faces
     '(ivy-current-match ((t (:box (:line-width 2 :style released-button)))))
     '(ivy-posframe-border ((t (:inherit internal-border :background "white" :foreground "white")))))
    ;;(setq ivy-posframe-width 50)
    (ivy-posframe-mode 1))

  (use-package swiper
    :disabled
    :bind (("C-s" . swiper-isearch)
           ("C-r" . swiper-isearch)
           ("C-c C-r" . ivy-resume))
    :hook (window-setup . ivy-fix)
    :custom
    ((ivy-use-virtual-buffers t)
     (ivy-display-style 'fancy))
    :config
    (ivy-mode 1)
    (define-key read-expression-map (kbd "C-r") 'counsel-expression-history))

  (use-package marginalia
    :config
    (marginalia-mode 1))
#+END_SRC

* Vertico Consult
#+BEGIN_SRC emacs-lisp
  ;; Enable vertico
  (use-package vertico
    :init
    (vertico-mode)
    (vertico-multiform-mode)
    :bind (:map vertico-map
                ("M-v" . #'vertico-multiform-vertical)
                ("M-g" . #'vertico-multiform-grid)
                ("M-f" . #'vertico-multiform-flat)
                ("M-R" . #'vertico-multiform-reverse)
                ("M-u" . #'vertico-multiform-unobtrusive))
    :config
    ;; Different scroll margin
    ;; (setq vertico-scroll-margin 0)

    ;; Show more candidates
    ;; (setq vertico-count 20)

    ;; Grow and shrink the Vertico minibuffer
    ;; (setq vertico-resize t)

    ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
    (setq vertico-cycle t))

  (use-package vertico-posframe
    ;;:disabled
    :init
    (vertico-posframe-mode)
    :config
    (setq vertico-multiform-commands
          '((consult-line posframe (vertico-posframe-poshandler . posframe-poshandler-frame-bottom-center))
            (consult-buffer posframe (vertico-posframe-poshandler . posframe-poshandler-frame-bottom-center))
            (t posframe (vertico-posframe-poshandler . posframe-poshandler-point-bottom-left-corner)))))

  ;; A few more useful configurations...
  (use-package emacs
    :init
    ;; Add prompt indicator to `completing-read-multiple'.
    ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
    (defun crm-indicator (args)
      (cons (format "[CRM%s] %s"
                    (replace-regexp-in-string
                     "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                     crm-separator)
                    (car args))
            (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
    ;; Vertico commands are hidden in normal buffers.
    ;; (setq read-extended-command-predicate
    ;;       #'command-completion-default-include-p)

    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t))

  ;; Example configuration for Consult
  (use-package consult
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings (mode-specific-map)
           ("C-c h" . consult-history)
           ("C-c m" . consult-mode-command)
           ("C-c k" . consult-kmacro)
           ;; C-x bindings (ctl-x-map)
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
           ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ;; M-g bindings (goto-map)
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings (search-map)
           ("M-s d" . consult-find)
           ("M-s D" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("C-s" . consult-line)
           ("C-S-s" . consult-line-multi)
           ("M-s m" . consult-multi-occur)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)                 ;; orig. next-matching-history-element
           ("M-r" . consult-history))                ;; orig. previous-matching-history-element

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key (kbd "M-."))
    ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key (kbd "M-.")
     :preview-key '(:debounce 0.4 any))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; (kbd "C-+")

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    ;; By default `consult-project-function' uses `project-root' from project.el.
    ;; Optionally configure a different project root function.
    ;; There are multiple reasonable alternatives to chose from.
    ;;;; 1. project.el (the default)
    ;; (setq consult-project-function #'consult--default-project--function)
    ;;;; 2. projectile.el (projectile-project-root)
    ;; (autoload 'projectile-project-root "projectile")
    ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
    ;;;; 3. vc.el (vc-root-dir)
    ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
    ;;;; 4. locate-dominating-file
    ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
    )
#+END_SRC

* Search Tooling
** ag
** rg
** ssh-agency
** persistent-scratch
#+BEGIN_SRC emacs-lisp
  (use-package ag
    :disabled
    :commands ag
    :init
    (warn-if-executable-not-found "ag" "apt install the-silver-searcher")
    :bind (("C-S-f" . consult-ripgrep)))   ;; for expanded results use ag command

  (use-package rg
    :commands rg
    :init
    (warn-if-executable-not-found "rg" "apt install rip-grep")
    :bind (("C-f" . consult-ripgrep)
           ("C-S-f" . consult-git-grep)))    ;; for expanded results use rg command

  ;; magit on ssh-protected git repos
  (use-package ssh-agency)

  ;; persistent-scratch
  (use-package persistent-scratch
    :config
    (persistent-scratch-setup-default))

  ;; Persist history over Emacs restarts. Vertico sorts by history position.
  (use-package savehist
    :init
    (savehist-mode))
#+END_SRC

* Fly Checker
** Whitespace
#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :hook
    (prog-mode . whitespace-mode)
    (prog-mode . display-fill-column-indicator-mode)
    :init
    (setq whitespace-global-modes '(not exwm-mode treemacs-mode Term-mode VTerm))
    (dolist (hook '(ansi-term-mode-hook
                    special-mode-hook
                    term-mode-hook
                    comint-mode-hook
                    compilation-mode-hook
                    minibuffer-setup-hook))
      (add-hook hook
                (lambda () (setq show-trailing-whitespace nil))))
    :custom
    (show-trailing-whitespace t)
    (fill-column 80)
    (whitespace-style (quote (face empty tabs whitespace))))
  #+END_SRC
** Flyspell
#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :init
    (warn-if-executable-not-found "aspell" "Install ispell or aspell")
    (defun flyspell-local-vars ()
      ;;(add-hook 'hack-local-variables-hook #'flyspell-buffer)
      )
    :hook
    (prog-mode . flyspell-prog-mode)
    (text-mode . flyspell-mode)
    (flyspell-mode . flyspell-local-vars))

  (use-package flyspell-correct-ivy
    :bind ("C-;" . flyspell-correct-wrapper)
    :init
    (global-eldoc-mode -1)
    (setq flyspell-correct-interface #'flyspell-correct-ivy))
#+END_SRC
** Fly check
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :hook (prog-mode . flycheck-mode)
    :custom
    (flycheck-set-indication-mode 'left-fringe)
    :init
    (global-flycheck-mode)
    (setq flycheck-global-modes '(not exwm-mode treemacs-mode))
    (add-to-list 'display-buffer-alist
                 `(,(rx bos "*Flycheck errors*" eos)
                   (display-buffer-reuse-window
                    display-buffer-in-side-window)
                   (side            . bottom)
                   (reusable-frames . visible)
                   (window-height   . 0.33)))
    (add-hook 'sh-mode-hook
              (lambda ()
                (defvar lsp-diagnostics-provider :none)
                (when (flycheck-may-enable-checker 'sh-shellcheck)
                  (flycheck-select-checker 'sh-shellcheck)))))
#+END_SRC


* Version Control  (Git, Git-Gutter, Git-timemachine, magit, smerge, direnv)
** Git
#+BEGIN_SRC emacs-lisp
    (use-package git-gutter
      :diminish
      :hook (after-init . global-git-gutter-mode)
      :init (setq git-gutter:visual-line t
                  git-gutter:disabled-modes '(asm-mode image-mode)
                  git-gutter:modified-sign "*"
                  git-gutter:added-sign "+"
                  git-gutter:deleted-sign "x")
      (warn-if-executable-not-found "git" "apt install git")
      :bind
      ("C-c g" . hydra-git-gutter/body))
    (defhydra hydra-git-gutter (:body-pre (git-gutter-mode 1)
                                          :hint nil)
      "
      Git gutter:
        _j_: next hunk        _s_tage hunk     _q_uit
        _k_: previous hunk    _r_evert hunk    _Q_uit and deactivate git-gutter
        ^ ^                   _p_opup hunk
        _h_: first hunk
        _l_: last hunk        set start _R_evision
      "
      ("j" git-gutter:next-hunk)
      ("k" git-gutter:previous-hunk)
      ("h" (progn (goto-char (point-min))
                  (git-gutter:next-hunk 1)))
      ("l" (progn (goto-char (point-min))
                  (git-gutter:previous-hunk 1)))
      ("s" git-gutter:stage-hunk)
      ("r" git-gutter:revert-hunk)
      ("p" git-gutter:popup-hunk)
      ("R" git-gutter:set-start-revision)
      ("q" nil :color blue)
      ("Q" (git-gutter-mode -1) :color blue))


    (use-package git-timemachine)

    (use-package magit
      :init
      (warn-if-executable-not-found "git" "sudo apt install git")
      (progn
        (bind-key "C-x g" 'magit-status))
      :config
      (with-eval-after-load 'magit-log
        (define-key magit-log-mode-map (kbd "<M-tab>") nil))
      (with-eval-after-load 'magit-status
        (define-key magit-status-mode-map (kbd "<M-tab>") nil))
      (with-eval-after-load 'magit-diff
        (define-key magit-diff-mode-map (kbd "<M-tab>") nil))
      :bind (:map magit-file-section-map
                  ("RET" . magit-diff-visit-file-other-window)
                  :map magit-hunk-section-map
                  ("RET" . magit-diff-visit-file-other-window))
      :custom
      ((magit-auto-revert-mode nil)
       (magit-ediff-dwim-show-on-hunks t)
       (magit-diff-arguments (quote ("--no-ext-diff" "-M" "-C")))
       (magit-diff-refine-hunk t)
       (magit-ediff-dwim-show-on-hunks t)
       (magit-expand-staged-on-commit (quote full))
       (magit-fetch-arguments (quote ("--prune")))
       (magit-log-auto-more t)
       (magit-log-cutoff-length 20)
       (magit-no-confirm (quote (stage-all-changes unstage-all-changes)))
       (magit-process-connection-type nil)
       (magit-push-always-verify nil)
       (magit-push-arguments (quote ("--set-upstream")))
       (magit-refresh-file-buffer-hook nil)
       (magit-save-some-buffers nil)
       (magit-set-upstream-on-push (quote askifnotset))
       (magit-stage-all-confirm nil)
       (magit-status-verbose-untracked nil)
       (magit-unstage-all-confirm nil)
       (magithub-message-confirm-cancellation nil)
       (magithub-use-ssl t)))
#+END_SRC
** Ediff
#+BEGIN_SRC emacs-lisp
  ;; Some custom configuration to ediff
  (use-package ediff
    :functions
    ediff-janitor ediff-cleanup-mess
    :custom
    ((ediff-split-window-function 'split-window-horizontally)
     (ediff-window-setup-function 'ediff-setup-windows-plain)
     (ediff-keep-variants nil))
    :config

    (defvar my-ediff-bwin-config nil "Window configuration before ediff.")
    (defcustom my-ediff-bwin-reg ?b
      "*Register to be set up to hold `my-ediff-bwin-config' configuration."
      :type 'integer ;; supress linter
      :group 'ediff)
    (defvar my-ediff-bwin-reg)

    (defvar my-ediff-awin-config nil "Window configuration after ediff.")
    (defcustom my-ediff-awin-reg ?e
      "*Register to be used to hold `my-ediff-awin-config' window configuration."
      :type 'integer    ;; supress linter
      :group 'ediff)
    (defvar my-ediff-awin-reg)

    (defun my-ediff-bsh ()
      "Function to be called before any buffers or window setup for ediff."
      (setq my-ediff-bwin-config (current-window-configuration))
      (when (characterp my-ediff-bwin-reg)
        (set-register my-ediff-bwin-reg
                      (list my-ediff-bwin-config (point-marker)))))

    (defun my-ediff-ash ()
      "Function to be called after buffers and window setup for ediff."
      (setq my-ediff-awin-config (current-window-configuration))
      (when (characterp my-ediff-awin-reg)
        (set-register my-ediff-awin-reg
                      (list my-ediff-awin-config (point-marker)))))

    (defun my-ediff-qh ()
      "Function to be called when ediff quits."
      (ediff-janitor nil nil)
      (ediff-cleanup-mess)
      (when my-ediff-bwin-config
        (set-window-configuration my-ediff-bwin-config)))

    ;; FRZ: TODO hooks cannot be placed in :hook section
    (add-hook 'ediff-before-setup-hook 'my-ediff-bsh)
    (add-hook 'ediff-after-setup-windows-hook 'my-ediff-ash 'append)
    (add-hook 'ediff-quit-hook 'my-ediff-qh)
    (message "[INFO] es/workarounds"))

    ;;https://ladicle.com/post/config/#smerge
  (use-package smerge-mode
    :diminish
    :preface
    (with-eval-after-load 'hydra
      (defhydra smerge-hydra
        (:color pink :hint nil :post (smerge-auto-leave))
        "
  ^Move^       ^Keep^               ^Diff^                 ^Other^
  ^^-----------^^-------------------^^---------------------^^-------
  _n_ext       _b_ase               _<_: upper/base        _C_ombine
  _p_rev       _u_pper              _=_: upper/lower       _r_esolve
  ^^           _l_ower              _>_: base/lower        _k_ill current
  ^^           _a_ll                _R_efine
  ^^           _RET_: current       _E_diff
  "
        ("n" smerge-next)
        ("p" smerge-prev)
        ("b" smerge-keep-base)
        ("u" smerge-keep-upper)
        ("l" smerge-keep-lower)
        ("a" smerge-keep-all)
        ("RET" smerge-keep-current)
        ("\C-m" smerge-keep-current)
        ("<" smerge-diff-base-upper)
        ("=" smerge-diff-upper-lower)
        (">" smerge-diff-base-lower)
        ("R" smerge-refine)
        ("E" smerge-ediff)
        ("C" smerge-combine-with-next)
        ("r" smerge-resolve)
        ("k" smerge-kill-current)
        ("ZZ" (lambda ()
                (interactive)
                (save-buffer)
                (bury-buffer))
         "Save and bury buffer" :color blue)
        ("q" nil "cancel" :color blue)))
    :hook ((find-file . (lambda ()
                          (save-excursion
                            (goto-char (point-min))
                            (when (re-search-forward "^<<<<<<< " nil t)
                              (smerge-mode 1)))))
           (magit-diff-visit-file . (lambda ()
                                      (when smerge-mode
                                        (smerge-hydra/body))))))

  (use-package direnv
    :init
    (warn-if-executable-not-found "direnv" "apt install direnv")
    :custom
    (direnv-always-show-summary nil)
    (direnv-show-paths-in-summary nil)
    :config
    (direnv-mode))
#+END_SRC

* Projects/Projectile
#+BEGIN_SRC emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Project Specific Setup                   ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (defun es/setup-project-dfn()
    "Setup DFN project."
    (interactive)
    (setenv "WRK" (concat (concat "/home/" (getenv "USER") "/dfn/dfinity/rs")))
    (setq compile-command
          "cd $WRK/;source ~/.nix-profile/etc/profile.d/nix.sh;nix-shell --run \"cargo build\"")
    )


  (defun es/setup-project-excb()
    "Setup Excubito Project."
    (interactive)
    (setenv "WRK" (concat (concat "/home/" (getenv "USER") "/excubito_workspace/hazen/.")))
    )

  (defun es/setup-project-apk()
    "Setup Excubito Project."
    (interactive)
    (setenv "WRK" (concat (concat "/home/" (getenv "USER") "/wrk/apk/.")))
    )
  (es/setup-project-apk)

  ;; Setup projectile
  (use-package counsel-projectile)

  (use-package projectile
    :config
    (projectile-mode 1)
    (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
    :init
    (projectile-add-known-project (getenv "WRK"))
    :bind
    ("C-c p" . hydra-projectile/body))

  (defhydra hydra-projectile-other-window (:color teal)
    "projectile-other-window"
    ("f"  projectile-find-file-other-window        "file")
    ("g"  projectile-find-file-dwim-other-window   "file dwim")
    ("d"  projectile-find-dir-other-window         "dir")
    ("b"  projectile-switch-to-buffer-other-window "buffer")
    ("q"  nil                                      "cancel" :color blue))

  (defhydra hydra-projectile (:exit nil
                                    :color teal
                                    :hint nil)
    "
       PROJECTILE: %(projectile-project-root)

       Find File            Search/Tags          Buffers                Cache
  ------------------------------------------------------------------------------------------
  _s-f_: file            _a_: ag                _i_: Ibuffer           _c_: cache clear
   _ff_: file dwim       _g_: update gtags      _b_: switch to buffer  _x_: remove known project
   _fd_: file curr dir   _o_: multi-occur     _s-k_: Kill all buffers  _X_: cleanup non-existing
    _r_: recent file                                               ^^^^_z_: cache current
    _d_: dir

  "
    ("a"   counsel-projectile-ag)
    ("b"   counsel-projectile-switch-to-buffer)
    ("c"   projectile-invalidate-cache)
    ("d"   counsel-projectile-find-dir)
    ("s-f" counsel-projectile-find-file)
    ("ff"  counsel-projectile-find-file-dwim)
    ("fd"  projectile-find-file-in-directory)
    ("g"   ggtags-update-tags)
    ("s-g" ggtags-update-tags)
    ("i"   projectile-ibuffer)
    ("K"   projectile-kill-buffers)
    ("s-k" projectile-kill-buffers)
    ("m"   projectile-multi-occur)
    ("o"   projectile-multi-occur)
    ("s-p" counsel-projectile-switch-project "switch project")
    ("p"   counsel-projectile-switch-project)
    ("s"   counsel-projectile-switch-project)
    ("r"   projectile-recentf)
    ("x"   projectile-remove-known-project)
    ("X"   projectile-cleanup-known-projects)
    ("z"   projectile-cache-current-file)
    ("`"   hydra-projectile-other-window/body "other window")
    ("q"   nil "cancel" :color blue))
#+END_SRC


* Programming common
** Yas
** Popup
** dap-mode
#+BEGIN_SRC emacs-lisp
  ;; YAS
  (use-package yasnippet-snippets)
  (use-package yasnippet
    :config
    (yas-global-mode 1)
    :bind
    (:map yas-minor-mode-map
          ("C-c & t" . yas-describe-tables)
          ("C-c & &" . org-mark-ring-goto)))
  (use-package yasnippet-snippets
    :pin gnu
    :defer)


  (use-package popup)
#+END_SRC

* Language server protocol (LSP)
** LSP-Mode
#+BEGIN_SRC emacs-lisp
  (custom-set-faces '(markdown-code-face ((t (:inherit default)))))
  (use-package lsp-mode
    :commands lsp
    :functions lsp-session lsp--persist-session
    :config
    (defun lsp-clear-session-blacklist()
      "Clear the list of blacklisted folders."
      (interactive)
      (setf (lsp-session-folders-blacklist (lsp-session)) nil)
      (lsp--persist-session (lsp-session)))
    :custom
    (lsp-auto-guess-root nil)
    (lsp-prefer-flymake nil) ; Use flycheck instead of flymake
    (lsp-restart 'auto-restart)
    (lsp-enable-file-watchers nil)
    (lsp-file-watch-threshold 64)
    (lsp-auto-guess-root nil)

    ;; completions are better handled by company-box
    (lsp-completion-no-cache nil)
    (lsp-modeline-code-actions-segments '(count icon name))

    ;; Function signature in modeline
    (lsp-signature-auto-activate nil)
    (lsp-signature-doc-lines 5)

    ;; Lsp eldoc and docbuffer integration.
    ;; How does this work ?
    ;;
    ;; Next to Completion: Completion can show function prototype in drop down.
    ;;                     This is disabled as it results in very wide boxes
    ;;
    ;; Completion Doc Frame: frameworks display doc-help, next to the completion drop down.
    ;; The documentation can browsed quickly by scroll-other-window C-M-v/V
    ;;
    ;; HOVER: Once the completion is selected, documentation can be looked up using mouse hover.
    ;;
    ;; ELDOC: copy pasting from hover is impractica. So the hover info is passed to eldoc buffer
    (lsp-completion-show-detail nil)  ;; Disable completion drop , function signatures
    (lsp-completion-show-kind nil)

    (lsp-eldoc-render-all t)    ;; push all availabe info to eldoc, let eldoc truncate and format
    (lsp-eldoc-enable-hover t)  ;; push info to eldoc we move mouse around

    (eldoc-echo-area-use-multiline-p 5);; Truncate modeline eldoc to just 5 lines. Else mode lines pops out
    (eldoc-echo-area-display-truncation-message t) ;; Display Help message if help is truncated
    (eldoc-echo-area-prefer-doc-buffer t);; Display in an existing eldoc buffer if available and skip mode like



    ;; rust
    (lsp-rust-wait-to-build 10000)
    (lsp-rust-build-on-save t)
    (lsp-rust-jobs 2)

    (lsp-rust-server 'rust-analyzer)
    (lsp-rust-analyzer-display-chaining-hints t)
    (lsp-rust-analyzer-display-parameter-hints t)

    ;; Very useful for writing code but, generally distracting got reading code
    ;; probably good to only enable if the buffer is dirty
    (lsp-rust-analyzer-server-display-inlay-hints t)
    (lsp-rust-full-docs t)

    ;; Rust lifetimes. Good for starters. Works only in X server mode
    (lsp-rust-analyzer-display-lifetime-elision-hints-enable t)
    (lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names t)

    ;;cpp
    (lsp-clients-clangd-args '("-j=4" "-background-index" "-log=error"))

    ;; `company-lsp' is automatically enabled
    ;; (lsp-enable-completion-at-point nil)
    (lsp-file-watch-ignored '(
                              "[/\\\\]\\.direnv$"
                                          ; SCM tools
                              "[/\\\\]\\.git$"
                              "[/\\\\]\\.cargo$"
                              "[/\\\\]\\.hg$"
                              "[/\\\\]\\.bzr$"
                              "[/\\\\]_darcs$"
                              "[/\\\\]\\.svn$"
                              "[/\\\\]_FOSSIL_$"
                                          ; IDE tools
                              "[/\\\\]\\.idea$"
                              "[/\\\\]\\.ensime_cache$"
                              "[/\\\\]\\.eunit$"
                              "[/\\\\]node_modules$"
                              "[/\\\\]\\.fslckout$"
                              "[/\\\\]\\.tox$"
                              "[/\\\\]\\.stack-work$"
                              "[/\\\\]\\.bloop$"
                              "[/\\\\]\\.metals$"
                              "[/\\\\]target$"
                                          ; Autotools output
                              "[/\\\\]\\.deps$"
                              "[/\\\\]build-aux$"
                              "[/\\\\]autom4te.cache$"
                              "[/\\\\]\\.reference$"
                                          ; rls cargo etc
                              "[/\\\\]\\result???$"
                              "[/\\\\]\\target???$"
                              "[/\\\\]\\.cargo-home???$"
                                          ; ccls cache
                              "[/\\\\]\\.ccls-cache$"
                                          ; all hidden folders
                              "[/\\\\]\\.$"
                              ))
    :bind (:map lsp-mode-map
                ("C-c C-l" . hydra-lsp/body)
                ("C-c C-f" . lsp-format-buffer)
                ("s-." . lsp-execute-code-action)
                ("M-m" . lsp-ui-mode))

    :hook (((prog-mode) . 'display-line-numbers-mode)
           (LaTeX-mode . lsp)
           (TeX-mode . lsp)
           (tex-mode . lsp)
           (latex-mode . lsp)
           ((prog-mode) . lsp)
           ;; (lsp-mode . lsp-enable-which-key-integration)
           (lsp-managed-mode . lsp-modeline-diagnostics-mode)
           (lsp-mode . lsp-headerline-breadcrumb-mode)
           (lsp-mode . lsp-modeline-code-actions-mode)))
#+END_SRC

** LSP-UI
#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui
    :diminish
    :bind (:map lsp-ui-mode-map
                ([remap xref-find-definitions] . lsp-ui-peek-find-definitions) ;; M-.
                ([remap xref-find-references] . lsp-ui-peek-find-references) ;; M-Shift-/
                ([remap xref-find-apropos] . lsp-ivy-workspace-symbol) ;; C-M-.
                ("C-c u" . lsp-ui-imenu))

    :custom
    (lsp-ui-doc-glance t)
    (lsp-ui-doc-header t)
    (lsp-ui-doc-include-signature t)
    (lsp-ui-doc-position 'bottom)
    (lsp-ui-doc-alignment 'window)

    (lsp-ui-sideline-enable t)
    (lsp-ui-sideline-ignore-duplicate t)
    (lsp-ui-sideline-mode t)
    (lsp-ui-sideline-show-code-actions t)
    (lsp-ui-sideline-show-hover t)
    (lsp-ui-sideline-update-mode 'line)
    (lsp-ui-sideline-diagnostic-max-line-length 40)

    ;;  Use lsp-ui-doc-webkit only in GUI
    (lsp-ui-doc-use-webkit nil)
    (lsp-ui-peek-enable t)
    (lsp-ui-peek-always-show t)
    (lsp-ui-imenu-enable t)
    (lsp-ui-flycheck-enable t)

    :config
    (setf truncate-lines t)
    ;;WORKAROUND Hide mode-line of the lsp-ui-imenu buffer
    ;;https://github.com/emacs-lsp/lsp-ui/issues/243
    (defadvice lsp-ui-imenu (after hide-lsp-ui-imenu-mode-line activate)
      (setq mode-line-format nil)))

  (use-package lsp-ivy)

  (defhydra hydra-lsp (:exit t :hint nil)
    "
   Buffer^^               Server^^                   Symbol
  -------------------------------------------------------------------------------------
   [_f_] format           [_M-r_] restart            [_d_] declaration  [_i_] implementation  [_o_] documentation
   [_m_] imenu            [_S_]   shutdown           [_D_] definition   [_t_] type            [_r_] rename
   [_x_] execute action   [_M-s_] describe session   [_R_] references   [_s_] signature       [_c_] clear blacklist
   [_e_] describe session"
    ("d" lsp-find-declaration)
    ("D" lsp-ui-peek-find-definitions)
    ("R" lsp-ui-peek-find-references)
    ("i" lsp-ui-peek-find-implementation)
    ("t" lsp-find-type-definition)
    ("s" lsp-signature-help)
    ("o" lsp-describe-thing-at-point)
    ("r" lsp-rename)
    ("e" lsp-describe-session)
    ("c" lsp-clear-session-blacklist)

    ("f" lsp-format-buffer)
    ("m" lsp-ui-imenu)
    ("x" lsp-execute-code-action)

    ("M-s" lsp-describe-session)
    ("M-r" lsp-workspace-restart)
    ("S" lsp-workspace-shutdown))
#+END_SRC

* Completion Engines (Company Corfu Autocomplete)
** Selector
#+BEGIN_SRC emacs-lisp
  (setq completion-engine "corfu")
  ;; (setq completion-engine "company")
  ;;(setq completion-engine "autocomplete")
  (defun company-engine()
    (string= completion-engine "company"))
  (defun corfu-engine()
    (string= completion-engine "corfu"))
  (defun ac-engine()
    (string= completion-engine "autocomplete"))
#+END_SRC
** Order less
#+BEGIN_SRC emacs-lisp
  ;; orderless let you fuzzy search completions
  ;; Optionally use the `orderless' completion style.
  (use-package orderless
    :init
    ;; Configure a custom style dispatcher (see the Consult wiki)
    ;; (setq orderless-style-dispatchers '(+orderless-dispatch)
    ;;       orderless-component-separator #'orderless-escapable-split-on-space)
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))
#+END_SRC
** Company
#+BEGIN_SRC emacs-lisp
  ;; Company
  (use-package company
    :if (company-engine)
    :hook (prog-mode . company-mode)
    :config
    (message "[INFO] es/completion engine COMPANY")
    (setq company-quickhelp-delay 1
          company-quickhelp-use-propertized-text nil
          lsp-completion-provider :capf
          company-minimum-prefix-length 1)
    (global-company-mode))

  (use-package company-quickhelp
    :if (company-engine)
    :hook (company-mode)
    :config
    (company-quickhelp-mode))

  (use-package company-box
    :if (company-engine)
    :hook (company-mode . company-box-mode)
    :custom (company-box-icons-alist 'company-box-icons-all-the-icons))

  (use-package company-posframe
    :if (company-engine)
    :config
    (company-posframe-mode))
#+END_SRC
** Corfu
#+BEGIN_SRC emacs-lisp
  ;; How does this work ?
  ;; Its fast auto-complete: i.e. If you idle around it will popup suggestion.
  ;; If you cancel a suggestion by backspace and then type in some initials THEN ... it completes in ORDERLESS fashion
  (use-package corfu
    :if (corfu-engine)
    ;; Optional customizations
    :custom
    (corfu-cycle t)                   ;; Enable cycling for `corfu-next/previous'
    (corfu-auto t)                    ;; Enable auto completion
    (corfu-auto-delay 0.0)
    (corfu-separator ?\s)             ;; Orderless field separator
    ;;(corfu-quit-at-boundary 'separator)   ;; Never quit at completion boundary
    (corfu-preview-current nil)
    ;;(corfu-preselect-first nil)       ;; Disable candidate preselection
    ;; (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
    ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches
    ;; (corfu-scroll-margin 5)        ;; Use scroll margin
    ;;(corfu-quit-no-match t)
    ;;    (corfu-echo-documentation nil)

    ;; Enable Corfu only for certain modes.
    :hook ((prog-mode . corfu-mode)
           (shell-mode . corfu-mode)
           (eshell-mode . corfu-mode))

    ;; Recommended: Enable Corfu globally.
    ;; This is recommended since Dabbrev can be used globally (M-/).
    ;; See also `corfu-excluded-modes'.
    :config
    (message "[INFO] es/completion engine CORFU")
    (setq lsp-completion-provider :none)
    (defun corfu-move-to-minibuffer ()
      (interactive)
      (let ((completion-extra-properties corfu--extra)
            completion-cycle-threshold completion-cycling)
        (apply #'consult-completion-in-region completion-in-region--data)))

    :bind (:map corfu-map
                ("M-RET" . corfu-info-documentation)
                ("M-SPC" . corfu-insert-separator)
                ("M-d" . corfu-doc-toggle)
                ("M-m" . corfu-move-to-minibuffer))

    :init
    (corfu-popupinfo-mode)
    (global-corfu-mode))

  (use-package corfu-terminal
    :after corfu
    :init
    (corfu-terminal-mode))

  (use-package kind-icon
    :if (corfu-engine)
    :after corfu
    :custom
    (kind-icon-default-face 'corfu-default) ; to compute blended backgrounds correctly
    (kind-icon-use-icons 'nil)
    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+END_SRC
** Auto-complete
#+BEGIN_SRC emacs-lisp
  (use-package auto-complete
    :if (ac-engine)
    :hook (prog-mode . auto-complete-mode)
    :disabled)
  (use-package auto-complete-config
    :if (ac-engine)
    :disabled
    :requires auto-complete)
#+END_SRC
* Programming Languages
** C/C++
#+BEGIN_SRC emacs-lisp
  ;; C/C++
  (use-package ccls
    :diminish
    :disabled
    :init
    (warn-if-executable-not-found "ccls" "snap install ccls")
    :config
    (message "[INFO] es/use-package-ccls")
    (defvar ccls-executable "/snap/bin/ccls")
    (defvar lsp-prefer-flymake nil)
    (setq-default flycheck-disabled-checkers '(c/c++-clang c/c++-cppcheck c/c++-gcc))
    (add-hook 'compilation-mode '(lamda ()
                                        (next-error-follow-minor-mode t)))
    :hook ((c-mode c++-mode objc-mode) .
           (lambda () (require 'ccls) (lsp))))

  (use-package ggtags
    :disabled
    :diminish)

  (use-package company-c-headers
    :diminish)


  (use-package clang-format
    :commands clang-format-buffer clang-format-region
    :init
    (warn-if-executable-not-found "clang-format" "apt install clang-format")
    (warn-if-executable-not-found "clangd" "sudo apt install clangd")
    (warn-if-executable-not-found "clang++" "sudo apt install llvm")
    (warn-if-executable-not-found "clang" "sudo apt install llvm")
    :config
    :custom
    (clang-format-executable "clang-format" t)
    (clang-format-style "Google")
    (c-echo-syntactic-information-p t)
    (c-insert-tab-function 'insert-tab)
    (c-report-syntactic-errors t))

  (use-package clang-format+
    :after clang-format
    :init
    (warn-if-executable-not-found "clang-format" "apt install clang-format"))
#+END_SRC
** Rust
#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :mode ("\\.rs\\'" . rust-mode)
    :init
    (warn-if-executable-not-found "rustfmt" "rustup component add rustfmt")
    :config
    (setq rust-format-on-save t))
  (use-package flycheck-rust
    :config (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
#+END_SRC
** Rust Cargo
#+BEGIN_SRC emacs-lisp
  ;; Add keybindings for interacting with Cargo
  (use-package cargo
    :init
    (warn-if-executable-not-found "cargo" "Install cargo from website")
    (warn-if-executable-not-found "cargo-add" "cargo install cargo-add")
    (warn-if-executable-not-found "cargo-expand" "cargo install cargo-expand")
    (warn-if-executable-not-found "cargo-clippy" "cargo install cargo-clippy")
    (warn-if-executable-not-found "cargo-rm" "cargo install cargo-rm")
    (warn-if-executable-not-found "cargo-watch" "cargo install cargo-watch")
    (warn-if-executable-not-found "cargo-upgrade" "cargo install cargo-upgrade")
    :hook (rust-mode . cargo-minor-mode))

  (defun rustzen()
    "Declutter rust lsp ui"
    (interactive)
    (setq lsp-rust-analyzer-server-display-inlay-hints nil))

#+END_SRC
** Haskell
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :mode ("\\.hs\\'" . haskell-mode))
  (use-package lsp-haskell
    :hook haskell-mode)

#+END_SRC

** Golang
#+BEGIN_SRC emacs-lisp
  ;; GO LANG ;;
  (use-package go-autocomplete)
  (require 'auto-complete-config)
  (defconst es/_goroot "/home/farazl/excubito_workspace/scratch/go/golang/go"  "Go toolchain root.")
  (defun ac-go-mode-setup()
    "Auto complete setup for go."
    ;;(setenv "PATH" (concat (getenv "PATH") ":" (concat es/_goroot "/bin")))
    (local-set-key (kbd "M-.") 'godef-jump)
    )

  (setenv "GOPATH" (getenv "WRK"))
  (defun go-set-gopath(_gopath)
    "Set up the path for GO workspace."
    (interactive "Set Go PATH:")
    (setenv "GOPATH" _gopath)
    )

  (add-hook 'go-mode-hook 'ac-go-mode-setup)
  (add-hook 'go-mode-hook 'ac-go-mode-setup)
#+END_SRC

** Javascript
#+BEGIN_SRC emacs-lisp
  ;; JavaScript ;;
  (defun js2-mode-setup()
    "Setup Tern mode for javascript."
    (tern-mode)
    (add-to-list 'company-backends 'company-tern)
    ;;  (auto-complete-mode)  // either AC + or company may Complete
    ;; Disable completion keybindings, as we use xref-js2 instead
    (define-key tern-mode-keymap (kbd "M-.") nil)
    (define-key tern-mode-keymap (kbd "M-,") nil)
    (local-set-key (kbd "s-a") 'adbShake)
    )

  (add-hook 'js2-mode-hook 'js2-mode-setup)
  (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
  (put 'downcase-region 'disabled nil)
  (message "[INFO] es/legacy-lang-setup")
#+END_SRC
** Python
#+BEGIN_SRC emacs-lisp
  ;; enable autopep8 formatting on save
  (use-package py-autopep8
    :hook (python-mode . py-autopep8-mode))
#+END_SRC
** YAML+ANSIBLE
#+BEGIN_SRC emacs-lisp
  ;; ansible
  (use-package yaml-mode
    :mode
    "\\.yml\\'"
    "\\.yaml\\'")
  (use-package ansible
    :init
    (add-hook 'yaml-mode-hook '(lambda () (ansible 1))))
  (use-package company-ansible)
#+END_SRC
** TOML
#+BEGIN_SRC emacs-lisp
  (use-package toml-mode
    :commands toml-mode
    :mode ("\\.toml\\'" . toml-mode))
#+END_SRC

* Text/PDF/Org
** ORG Mode
#+BEGIN_SRC emacs-lisp
  (use-package org
    :pin gnu
    :mode (("\\.org$" . org-mode))
    :hook
    (org-mode . org-superstar-mode)
    (org-mode . toc-org)
    (org-mode . org-bullets)
    :config
    (setq org-startup-folded t)
    (setq org-startup-indented t)
    (setq org-startup-with-inline-images t)
    (progn
      ;; config stuff
      (if (file-exists-p "~/agenda/todo.org")
          (add-to-list 'org-agenda-files "~/agenda/todo.org"))
      (if (file-exists-p "~/agenda/notes.org")
          (add-to-list 'org-agenda-files "~/agenda/notes.org"))))
  (use-package org-superstar
    :after org
    :config
    (org-superstar-mode 1))
  (use-package org-bullets
    :after org
    :config
    (org-bullets-mode 1))
  (use-package toc-org
    :after org
    :config
    (toc-org-mode 1))
#+END_SRC
** Latex
#+BEGIN_SRC emacs-lisp
  (use-package lsp-latex
    :init
    (warn-if-executable-not-found "texlab" "Install texlab cargo install texlab")
    :mode ("\\.tex\\'" . tex-mode)
    :custom
    (lsp-latex-build-is-continuous t)
    (lsp-latex-chktex-on-edit t)
    (lsp-latex-chktex-on-open-and-save t)
    (lsp-latex-build-on-save t)
    :hook ((LaTeX-mode . lsp)
           (TeX-mode . lsp)
           (tex-mode . lsp)
           (latex-mode . lsp)))
  (use-package latex-preview-pane
    :mode ("\\.tex\\'" . tex-mode)
    :config
    (latex-preview-pane-mode 1))
#+END_SRC

** PDF Tools
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :magic ("%PDF" . pdf-view-mode)
    :config
    (pdf-tools-install))
#+END_SRC
** Grammarly + LTEX
#+BEGIN_SRC emacs-lisp
  (use-package grammarly
    :ensure t
    :hook (text-mode . (lambda ()
                         (require 'lsp-grammarly)
                         (lsp))))
  (use-package lsp-grammarly)
  (use-package flycheck-grammarly)

  (use-package lsp-ltex
    :ensure t
    :hook (text-mode . (lambda ()
                         (require 'lsp-ltex)
                         (lsp)))  ; or lsp-deferred
    :init
    (setq lsp-ltex-version "15.2.0"))  ; make sure you have set this, see below
#+END_SRC


* Package loading done
#+BEGIN_SRC emacs-lisp
  (message "[INFO] !!es/packages-loaded!!")
#+END_SRC


* Keyboard Setup
#+BEGIN_SRC emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;
  ;; Keyboard Setup  ;;
  ;;;;;;;;;;;;;;;;;;;;;
  (defun es/input-decode-map-putty()
    "Keys for iterm2.  You have to edit corresponding entries in iterm."
    (interactive)
    (define-key input-decode-map "\e[A" [(meta up)])
    (define-key input-decode-map "\e[B" [(meta down)])
    (define-key input-decode-map "\ef" [(meta right)])
    (define-key input-decode-map "\eb" [(meta left)])
    ;; putty sends escape sequences
    (define-key input-decode-map "\e\eOA" [(meta up)])
    (define-key input-decode-map "\e\eOB" [(meta down)])
    (define-key input-decode-map "\e\eOC" [(meta right)])
    (define-key input-decode-map "\e\eOD" [(meta left)]))

  (defun es/input-decode-map-xterm-compatibility()
    "Key bindinds based on xterm.defaullts presets set by iterm2."
    (interactive)
    (define-key input-decode-map "\e[1;5A" [(ctrl up)])
    (define-key input-decode-map "\e[1;5B" [(ctrl down)])
    (define-key input-decode-map "\e[1;5C" [(ctrl right)])
    (define-key input-decode-map "\e[1;5D" [(ctrl left)])

    (define-key input-decode-map "\e[1;3A" [(meta up)])
    (define-key input-decode-map "\e[1;3B" [(meta down)])
    (define-key input-decode-map "\e[1;3C" [(meta right)])

    (define-key input-decode-map "\e[1;3D" [(meta left)]))

  (add-hook 'tty-setup-hook 'es/input-decode-map-xterm-compatibility)

  ;; windmove gnome terminal keys
  (defvar real-keyboard-keys
    '(("M-<up>"        . "\M-[1;3A")
      ("M-<down>"      . "\M-[1;3B")
      ("M-<right>"     . "\M-[1;3C")
      ("M-<left>"      . "\M-[1;3D")
      ("C-<return>"    . "\C-j")
      ("C-<delete>"    . "\M-[3;5~")
      ("C-<up>"        . "\M-[1;5A")
      ("C-<down>"      . "\M-[1;5B")
      ("C-<right>"     . "\M-[1;5C")
      ("C-<left>"      . "\M-[1;5D"))
    "An assoc list of pretty key strings and their terminal equivalents.")

  (defun key (desc)
    "Elint DESC suppress."
    (or (and window-system (read-kbd-macro desc))
        (or (cdr (assoc desc real-keyboard-keys))
            (read-kbd-macro desc))))
#+END_SRC
* File Experimental
#+BEGIN_SRC emacs-lisp
#+END_SRC

* Restore GC
#+BEGIN_SRC emacs-lisp
  ;; Make gc pauses faster by decreasing the threshold.  This works in
  ;; conjunction with gc setting set up in the starting of the file
  (setq gc-cons-threshold (* 128 1000 1000))
#+END_SRC

* Emacs server
#+BEGIN_SRC emacs-lisp
  (setq server-socket-dir "~/.emacs.d")
  (load "server")
  (unless (server-running-p) (server-start) (message "[INFO] !!!server started!!!"))
#+END_SRC

* Emacs Customs to<>from another file
#+BEGIN_SRC emacs-lisp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Setup common variables across packages ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (setq custom-file "~/.emacs_custom.el")
  (load custom-file t)
#+END_SRC

* Emacs Load complete
#+BEGIN_SRC emacs-lisp
  (message "[INFO] !!!es/load-complete!!!")
  (provide '.emacs)
  ;;; .emacs ends here
#+END_SRC

# Local Variables:
# flycheck-disabled-checkers: emacs-lisp-checkdoc lsp
# End:
